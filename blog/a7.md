# A7

阅读 P523 对应章节至  things-to-do，对照着看。

+ RemoveComplexOpera
+ FlattenSet

在 A6 还不明显，但从 A7 来看，以上两个 Pass 已经可以合并在一起了。

+ ImposeCallingConvention

A7 将处理非尾调用，它跟尾调用有非常明显的区别。

对于一个非尾调用，它的实际参数中，能够分配到寄存器还是照旧，按调用约定分配。但是溢出的变量的帧位置却推迟赋值。为什么呢？因为在 P523 中，作者的思路是，在当前这个尾调用中，收集所有发生的非尾调用的溢出变量，然后根据这些变量的多少，分配一个足够大的帧给它们使用。

ReturnPoint 包含一个 rp 和一个 tail，这个 tail 将不会结束程序，而是会重新返回到 rp。

nfv 虽然是一个变量，但它是注定要分配到帧上的变量。

+ UncoverFrameConflict

我们再次遇到了 call-live。之前写过一个 DiscardCallLive 的 Pass，所以 call-live 就是 ReturnPoint 中的 tail 中的 Funcall 的 args！

此外，liveness 分析有点变化。ReturnPoint 入口处的 liveset 包含两个部分：

1. ReturnPoint 返回时的 call-live（也就是 args） 
2. ReturnPoint 中的 tail 的入口处的 liveset

在 UncoverConflict 中进行收集。

call-live 中所有的变量都被收集进 spills，在随后的 pass 中进行分配。这个 Call-live 是属于 Caller 的。

+ PreAssignFrame

跟 AssignFrame 本质上是一样的，在这之后，call-live 中不存在变量。因为这些变量已经被分配了帧位。


+ AssignNewFrame

根据 call-live 确定 caller 的帧大小。所有的 callee 的变量（nfv）就叠在 Caller 帧的上方。

最后，在执行每一个 nontail call 之前，先把 fp 移动 caller 的帧顶，然后进行调用，结束之后，将 fp 移回原处。

+ FinalizeFrameLocations

将上一步的 nfv 替换成对应的帧位置。

+ ExposeFrameVar

在 P523 中，这一步将会把 fvi 正式替换成内存地址。但是，ReturnPoint 之前，我们会把 fp 调高，ReturnPoint 当中是有可能包含 nfv 的，这些 nfv 已经变成了对应的帧位（FinalizeFrameLocations)。它们可能是类似 fv3, fv4 这样的格式。在调高 fp 之后，它们的位置已经变成了像 fv0, fv1 这样。所以，这些变量需要被进一步修改。

当然，我们之前并没有这个 Pass，现在可以加上了！但为了明确这个 Pass 的含义，就叫 UpdateFrameLocations 吧。


+ ExposeBasicBlocks

在遇到 ReturnPoint(labl, tail) 的时候，把 ReturnPoint 后面的语句打包，贴上 labl。把 tail 当作正常的 tail 来处理并返回。