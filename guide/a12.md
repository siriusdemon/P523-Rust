# A12

The note of A12 is lost. I try to regain it by some code and annotation.

A12 add `procedure` in the language.


### VerifyScheme

verify-scheme accept a single value and verifies that the value is a valid program in the current source language.

The grammar changes only slightly from Assignment 11 in that `labels` no longer appear in the source language.  Also, the set of variables visible within each lambda expression now includes those bound by let, letrec, and lambda expressions enclosing the lambda expression.

Grammar for verify-scheme (assignment 12):

```lisp
  Program --> Expr
  Expr    --> uvar
          |  (quote Immediate)
          |  (if Expr Expr Expr)
          |  (begin Expr* Expr)
          |  (let ([uvar Expr]*) Expr)
          |  (letrec ([uvar (lambda (uvar*) Expr)]*) Expr)
          |  (primitive Expr*)
          |  (Expr Expr*)
  Immediate -> fixnum | () | #t | #f
```
Where uvar is symbol.n, n >= 0. fixnum is an exact integer. 



```lisp
primitive table:

| primitives     | arguments | context   |
|:--------------:|:---------:|:---------:|
| void           | 0         | Value     |
| car            | 1         | Value     |
| cdr            | 1         | Value     |
| vector-length  | 1         | Value     |
| make-vector    | 1         | Value     |
| +              | 2         | Value     |
| -              | 2         | Value     |
| *              | 2         | Value     |
| boolean?       | 1         | Predicate | 
| fixnum?        | 1         | Predicate | 
| null?          | 1         | Predicate | 
| pair?          | 1         | Predicate | 
| procedure?     | 1         | Predicate | 
| vector?        | 1         | Predicate | 
| <              | 2         | Predicate | 
| <=             | 2         | Predicate | 
| =              | 2         | Predicate | 
| >=             | 2         | Predicate | 
| >              | 2         | Predicate | 
| eq?            | 2         | Predicate | 
| set-car!       | 2         | Effect    | 
| set-cdr!       | 2         | Effect    | 
| vector-set!    | 3         | Effect    | 
```

Within the same Program, each uvar bound by a lambda, let, or letrec expression must have a unique suffix. 

Machine constraints: each fixnum must be an exact integer n, -2^(k-1) <= n <= 2^(k-1)-1, where k is the value of the helpers.ss variable fixnum-bits

If the value is a valid program, verify-scheme returns the value unchanged; otherwise it signals an error.


### UncoverFree

Uncover free basically finds the variables that are free in a lambda body and just wraps around a new form

```lisp
    free (var*) (lambda (args*) ...)
```
as shown. 

Free variable is those variables that appear in the body of a lambda but not in the set of arguments.


Output Grammar of uncover-free 

```lisp
  Program --> Expr
  Expr    --> uvar
          |  (quote Immediate)
          |  (if Expr Expr Expr)
          |  (begin Expr* Expr)
          |  (let ([uvar Expr]*) Expr)
          |  (letrec ([uvar (lambda (uvar*) (free (free-var*) Expr))]*) Expr)
          |  (primitive Expr*)
          |  (Expr Expr*)
  Immediate -> fixnum | () | #t | #f
```


### ConvertClosure

This pass firstly passes every lambda expresson with an additional pointer called the closure pointer, this closure pointer basically references to itself. the free-form is changed to bind-free and also adds the function-pointer to the list, we also have to convert all the uvars bound to function definitions to labels

We also wrap around the body of a letrec expression with a closures form which is a list mapping uvars to the labels and the free parameters they take. Once this transformation has been made, all letrec-bound procedures are closed (have no free variables), thus they are simply labeled blocks of code.

Output Grammar for convert-closures

```lisp
  Program --> Expr
  Expr    --> uvar
          |  (quote Immediate)
          |  (if Expr Expr Expr)
          |  (begin Expr* Expr)
          |  (let ([uvar Expr]*) Expr)
          |  (letrec ([label (lambda (cp uvar*) (bind-free (cp free-var*) Expr))]*) 
                (closures (uvar* label* free*) Expr))
          |  (primitive Expr*)
          |  (Expr Expr*)
  Immediate -> fixnum | () | #t | #f
```


### IntroduceProceduraPrimitives




### Refer
https://github.com/spiritbear/Grad-School-Code/blob/master/Assignment-12/a12.ss