# A12

The note of A12 is lost. I try to regain it by some code and annotation.

A12 add `procedure` in the language.


### VerifyScheme

verify-scheme accept a single value and verifies that the value is a valid program in the current source language.

The grammar changes only slightly from Assignment 11 in that `labels` no longer appear in the source language.  Also, the set of variables visible within each lambda expression now includes those bound by let, letrec, and lambda expressions enclosing the lambda expression.

Grammar for verify-scheme (assignment 12):

```lisp
  Program --> Expr
  Expr    --> uvar
          |  (quote Immediate)
          |  (if Expr Expr Expr)
          |  (begin Expr* Expr)
          |  (let ([uvar Expr]*) Expr)
          |  (letrec ([uvar (lambda (uvar*) Expr)]*) Expr)
          |  (primitive Expr*)
          |  (Expr Expr*)
  Immediate -> fixnum | () | #t | #f
```
Where uvar is symbol.n, n >= 0. fixnum is an exact integer. 



```lisp
primitive table:

| primitives     | arguments | context   |
|:--------------:|:---------:|:---------:|
| void           | 0         | Value     |
| car            | 1         | Value     |
| cdr            | 1         | Value     |
| vector-length  | 1         | Value     |
| make-vector    | 1         | Value     |
| +              | 2         | Value     |
| -              | 2         | Value     |
| *              | 2         | Value     |
| boolean?       | 1         | Predicate | 
| fixnum?        | 1         | Predicate | 
| null?          | 1         | Predicate | 
| pair?          | 1         | Predicate | 
| procedure?     | 1         | Predicate | 
| vector?        | 1         | Predicate | 
| <              | 2         | Predicate | 
| <=             | 2         | Predicate | 
| =              | 2         | Predicate | 
| >=             | 2         | Predicate | 
| >              | 2         | Predicate | 
| eq?            | 2         | Predicate | 
| set-car!       | 2         | Effect    | 
| set-cdr!       | 2         | Effect    | 
| vector-set!    | 3         | Effect    | 
```

Within the same Program, each uvar bound by a lambda, let, or letrec expression must have a unique suffix. 

Machine constraints: each fixnum must be an exact integer n, -2^(k-1) <= n <= 2^(k-1)-1, where k is the value of the helpers.ss variable fixnum-bits

If the value is a valid program, verify-scheme returns the value unchanged; otherwise it signals an error.


### UncoverFree

Uncover free basically finds the variables that are free in a lambda body and just wraps around a new form

```lisp
    free (var*) (lambda (args*) ...)
```
as shown. 

Free variable is those variables that appear in the body of a lambda but not in the set of arguments.


Output Grammar of uncover-free 

```lisp
  Program --> Expr
  Expr    --> uvar
          |  (quote Immediate)
          |  (if Expr Expr Expr)
          |  (begin Expr* Expr)
          |  (let ([uvar Expr]*) Expr)
          |  (letrec ([uvar (lambda (uvar*) (free (free-var*) Expr))]*) Expr)
          |  (primitive Expr*)
          |  (Expr Expr*)
  Immediate -> fixnum | () | #t | #f
```

+ for uvar and quote, fvars is empty. 
+ for If, fvars is union of test, consequence and alternative.
+ for begin, fvars is union of all the exprs.
+ for let, fvars is union of all its value exprs except let-bounding variables.
+ for letrec, fvars is union of all lambdas except letrec-bounding variables
+ for primitive, fvars is union of all its operands
+ for funcall, fvars is union of the function and the arguments'


For example

```lisp
(letrec ([map.1 (lambda (f.2 ls.3)
                 (if null? ls.3)
                    '()
                    (cons (f.2 (car ls.3))
                        (map.1 f.2 (cdr ls.3))))])
    (void))
```

becomes

```lisp
(letrec ([map.1 (lambda (f.2 ls.3)
                  (free (map.1)                 ; free variables here
                    (if null? ls.3)
                        '()
                        (cons (f.2 (car ls.3))
                            (map.1 f.2 (cdr ls.3)))))])
    (void))
```


### ConvertClosure

This pass will convert lambda expressions with free variables into lambda expressions without free variables and add a closure form which stores a pointer to the procedure code and the value of free variables

Output Grammar for convert-closures

```lisp
  Program --> Expr
  Expr    --> uvar
          |  (quote Immediate)
          |  (if Expr Expr Expr)
          |  (begin Expr* Expr)
          |  (let ([uvar Expr]*) Expr)
          |  (letrec ([label (lambda (cp uvar*) (bind-free (cp free-var*) Expr))]*) 
                (closures ([uvar* label free-var*]*) Expr))
          |  (primitive Expr*)
          |  (Expr Expr*)
  Immediate -> fixnum | () | #t | #f
```

`cp` means `closure pointer`


the syntax change from 

```lisp
(letrec ([uvar (lambda (uvar*) 
                    (free (free-var*) Expr))]*)
    Expr)
```

into
```lisp
(letrec ([label (lambda (cp uvar*)
                    (bind-free (cp free-var*) Expr))]*)
    (closures ([uvar* label free-var*]*) Expr))
```

The detail is following:

1. Every letrec-bound uvar should generate a label and a closure pointer, using (unique-label uvar) and (unique-label "cp").
2. The generated label is used as a normal label to bind the lambda form. The generated cp is passed as first argument to the binding lambda form. At the same time, the free form of the lambda form also adds the cp and transform into a bind-free form. Thus we finish processing the lambda form.
3. Finally, the value part of letrec is wrapped by a `closures` form which collects the original uvar (used to bind lambda form), its corresponding label and free-var.


Since function args have an extra `cp`, function call should also introduce a `cp`, which is the function name itself.

```lisp
(f args) => (f f args)
((return-f) args) => (let ([f (return-f)])
                        (f f args))
```

After this pass, lambdas are closed. free-var in lambda's body will be replaced by access to a `cp` in the next pass, so there is no free variables anymore.


Example:

```lisp
(letrec ([map.1 (lambda (f.2 ls.3)
                  (free (map.1)                 ; free variables here
                    (if null? ls.3)
                        '()
                        (cons (f.2 (car ls.3))
                            (map.1 f.2 (cdr ls.3)))))])
    (void))
```

becomes

```lisp
(letrec ([map$5 (lambda (cp.4 f.2 ls.3)
                  (bind-free (cp.4 map.1)                       ; bind-free variables here
                    (if null? ls.3)
                        '()
                        (cons (f.2 f.2 (car ls.3))              ; add cp here
                            (map.1 map.1 f.2 (cdr ls.3)))))])   ; add cp here
    (closures ([map.1 map$5 map.1])
        void))
```



### IntroduceProceduraPrimitives

This program complete closure conversion by introducing procedure primitives and eliminating bind-free and closure forms. Every reference to a free variable is replaced with a `procedure-ref` to the cp.


The memory structure of a procedure:
```lisp
-------------------------------------
| Code | fvar1 | fvar2 | fvar2 | ...|
-------------------------------------
^
cp
```
`(make-procedure label size)` alloc a memory for a procedure. Set the value of  `code` field with `label`
```lisp
(make-procedure label size) => (let ([tmp (+ (alloc (+ disp-procedure-data n)) tag-procedure)])
                                  (begin
                                    (mset! tmp offset-procedure-code label)
                                    tmp))
```
where `tmp` is a fresh uvar, `offset-procedure-code` is computed by  `(- disp-procedure-code tag-procedure)`

The rest operations are similar to vector's.

+ (procedure-ref cp i) => (vector-ref vec i)
+ (procedure-set! cp i v) => (vector-set! vec i v)
+ (procedure-code cp) => (vector-length vec)


For example

```lisp
(letrec ([map$5 (lambda (cp.4 f.2 ls.3)
                  (bind-free (cp.4 map.1)                       ; bind-free variables here
                    (if null? ls.3)
                        '()
                        (cons (f.2 f.2 (car ls.3))              ; add cp here
                            (map.1 map.1 f.2 (cdr ls.3)))))])   ; add cp here
    (closures ([map.1 map$5 map.1])
        void))
```

becomes

```lisp
(letrec ([map$5 (lambda (cp.4 f.2 ls.3)
                  (bind-free (cp.4 map.1)                       ; bind-free variables here
                    (if null? ls.3)
                        '()
                        (cons (f.2 f.2 (car ls.3))              ; add cp here
                            (map.1 map.1 f.2 (cdr ls.3)))))])   ; add cp here
    (closures ([map.1 map$5 map.1])
        void))
```


After this pass, procedure-code procedure-ref make-procedure procedure-set! is available.

### SpecifyRepresentation

should handle `procedure?`, `procedure-ref`, `procedure-code`, `procedure-set!`


### Refer
+ [yscheme](/yscheme.ss)
+ https://github.com/pavenvivek/Compiler-for-Scheme/tree/master/Compiler 
+ https://github.com/spiritbear/Grad-School-Code/blob/master/Assignment-12/a12.ss


### My Reference Code

From A12, crate `Uuid` is removed.