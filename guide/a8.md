# A8

自作主张的时候。



+ RemoveComplexOpera
+ FlattenSet

功能不变，将 value 完全移除。

移除之后，

tail    => (alloc trim)
           (mref trim trim)
effect  => (mset! trim trim trim)
        => (set! sym (alloc size))
        => (set! sym (mref base offset))


+ ImposeCallingConvention

tail 处的 alloc
```rs
(alloc usize) => (begin
                    (set! ra ap)
                    (set! ap (+ ap usize)))
```

tail 处的 mref 像 atom 那样处理

effect 处的 alloc

```rs
(set! uvar (alloc usize)) => (begin
                                (set! uvar ap)
                                (set! ap (+ ap usize)))
```

effect 处的 mref 不做处理

effect 处的 mset! 不做处理

liveset 应当包含 ALLOCATION_REGISTER

这个 Pass 的输出中 

effect  =>  (set! x (mref base offset))
            (mset! base offset value)

+ UncoverConflict

mref / mset! 都算作 read，因为 mset! 并不会修改 base.

```rs
(mset! base 0 new-base)
(set! base new-base)
```
这两者有什么区别？用 C 来比喻。
```rs
(mset! base 0 new-base) => base[0] = new-base
(set! base new-base) => base = new-base
```

+ SelectInstructions

mref 中的 base, offset 不能同时是数字。且不能出现 fv

mset 中 base, offset 同样不能同时是数字，且不能出现 fv，且 value 不能是 fv。


+ FinalizeFrameLocations 

对 mref , mset 进行处理。

+ FinalizeLocations

对 mref , mset 进行处理。

+ CompileToAsm

syntax.rs 中新增 DerefRegister，表示 (%rax, %rax) 这种语法。

对应处理 mref, mset